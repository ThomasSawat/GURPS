from datetime import datetime,timedelta
from decimal import *
from math import *
import csv
import matplotlib.pyplot as plt
import random
import time
"""
Type
	A
		Change the amount of recovered MB per day
	R
		Reset the Queue to zero
	T
		Transmit data
	V
		Change recovery variance
"""

##############
### CONFIG ###
##############

currentByteStorage = 0

dataFileStr = "data/transmits.csv"

maxByteStorage = 50*2**30

missionYears = 5

recoveredBytesPerDay = 50*(2**30)

recoveryVariance = 1

startDate = datetime(2017,9,22)

# View min/max
	# Set to [] to view the full range
viewMin = startDate
viewMax = startDate + timedelta(days=30)

# NEVER CHANGE THESE!!!!!
timeStep = timedelta(minutes=15)
random.seed("Colony World")

##################
### END CONFIG ###
##################

#################
### FUNCTIONS ###
#################


def SumQueue(data):
	sumVal = 0
	for i in data:
		sumVal+=data[2]
	return sumVal


#####################
### END FUNCTIONS ###
#####################


#################
### CALCULATE ###
#################

endDate = startDate + timedelta(days=missionYears*365)

if(viewMin == []):
	viewMin = startDate
if(viewMax == []):
	viewMax = endDate

###########
### RUN ###
###########

start = time.time()
dataReader = csv.reader(open(dataFileStr,"rb"))
dataReader.next()
dataTrans=list()
for i in dataReader:
	try:
		dataTrans.append( (datetime.strptime(i[0],"%m/%d/%Y %H:%M:%S"),float(i[2]),i[3],i[4]))
	except:
		print i
		time.sleep(0.1)
		raise
x=list()
y=list()
y2=list()
curDate = startDate
indexVal = 0
dataQueue = list();
print "Simulate..."
while(curDate < endDate):
	#print curDate
	while(indexVal < len(dataTrans) and dataTrans[indexVal][0] < curDate):
		# Q Up New Transfers and Byte Rate Changes
		#print dataTrans[indexVal]
		if(dataTrans[indexVal][2]=="T"):
			#print "Transfer"
			dataQueue.append(dataTrans[indexVal][1])
		elif(dataTrans[indexVal][2]=="A"):
			recoveredBytesPerDay = dataTrans[indexVal][1]*2**20
			#print "Alter Data Rate"
		elif(dataTrans[indexVal][2]=="R"):
			dataQueue = list()
		elif(dataTrans[indexVal][2]=="V"):
			recoveryVariance = dataTrans[indexVal][1]
		else:
			print "Error! Cannot read line:"
			print dataTrans[indexVal]
		indexVal+=1
	# Process Data Queue
	if(len(dataQueue)):
		# Loop through the Queue until we burn out data or run out of Queue
		for i in range(len(dataQueue)):
			# Convert MB to B and compare
			if(dataQueue[0]*2**20 > currentByteStorage):
				dataQueue[0]-=currentByteStorage/(2**20)
				currentByteStorage=0
				break
			else:
				currentByteStorage -= dataQueue[0]*(2**20)
				del dataQueue[0]
				if(len(dataQueue)==0):
					break
	# Recovery Bytes

	x.append(curDate)
	y.append(currentByteStorage/(2**30))
	y2.append(sum(dataQueue)/(2**10))

	currentByteStorage += recoveredBytesPerDay*(timeStep.total_seconds()/(24.*60.*60.)) * random.gauss(1,recoveryVariance)
	if(currentByteStorage > maxByteStorage):
		currentByteStorage = maxByteStorage 
	elif(currentByteStorage<0):
		currentByteStorage = 0
	curDate += timeStep
print "Plot..."
fig, ax = plt.subplots(1)
plt.plot(x,y,x,y2)
fig.autofmt_xdate()
plt.xlim(viewMin,viewMax)
plt.ylabel("Data (GiB)")
print "Fin!"
print "Time: ",time.time()-start
plt.show()